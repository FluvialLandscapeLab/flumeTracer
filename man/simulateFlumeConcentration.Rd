% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/flumeTracer.R
\name{simulateFlumeConcentration}
\alias{simulateFlumeConcentration}
\title{Model a flume tracer release.}
\usage{
simulateFlumeConcentration(m, debug = F)
}
\arguments{
\item{m}{An environment (often created with \code{\link{createFlume}}) in which the follow variables have been defined:
  \itemize{

  \item{\code{timestep} the time period each iteration of the model
  represents}

  \item{\code{duration} the total duration of the simulation}

  \item{\code{tau_0} the minimum water age in the hyporheic zone}

  \item{\code{tau_n} the maximum water age in the hyporheic zone}

  \item{\code{shape} either "powerLaw" or "exponent" depending on the desired
  shape of the washout function.}

  \item{\code{alpha} or \code{sigma} the exponent for shape "powerLaw"
  (\code{alpha} -- use a positive value. This value is negated within the
  model code...) or the decay rate (\code{sigma}) for shape "exponent".}

  \item{\code{C_c} the initial channel (surface water) concentration
  immediately following the slug release}

  \item{\code{C_h} the initial hyporheic water concentration (equal to
  concentration prior to the release)}

  \item{\code{V} the total water volume in the flume}

  \item{\code{V_h} the water volume within the hyporheic zone}

  \item{\code{nSubdiv} the number of manual subdivisions used for
  integration.  Use 3 as an initial value.  Try increasing this value if
  "divergent integration" errors arise, or to improve the accuracy of the
  integration (at the cost of increased computational time).  A value above
  about 15 is not likely to improve things.}

  }}

\item{debug}{Control debugging output. The model relies substantially on
numerical integration.  If \code{debug} is set to TRUE, the model will
record the integration quality information for every numerical integration
to a variable called \code{debug} in the model environment passed to
\code{m}.  This will slow the model execution somewhat and is extremely
verbose.}
}
\value{
TRUE if executed successfully.

  As a side effect, the following values are added to the environment
  \code{m}:

  \itemize{

  \item{\code{nIterations} The number of iterations executed by the model.}

  \item{\code{times} The time values at the end of each iteration.  This
  variable is useful as an x-axis for plotting time series results.}

  \item{\code{nTimes} The length of any time series produced by the model
  (nIterations + 1, because initial conditions are include in all time series
  variables.}

  \item{\code{V_c} The volume of surface water (difference between V and
  V_h)}

  \item{\code{C_final} The expected final concentration in the flume;
  calculated as \code{(C_c*V_c + C_h*V_h) / V}}

  \item{\code{debug}} Information about the quality of numerical integrations
  used in the model.  Only created if \code{debug} parameter is set to TRUE.

  } Also, \code{C_c} is converted to a time series of length \code{nTimes}.
}
\description{
Simulates conservative tracer concentration in an annular flume following a
slug release.
}
\details{
Uses and implicit solver to estimate flume channel water concentration at
each time step of a simulation.

When the function if executed, the period of record for channel concentration
is built, one value at a time, via iteration.  The implicit solver takes
advantage of the fact that the mean concentration of water in the flume at
the end of the salt release is known:

\code{C_final = (C_prerelease * V + C_slug * V_slug)/(V + V_slug) }

where V is total water volume in flume.

Alternatively, if the instantaneous flume concentration at the time of slug
injection can be estimated:

\code{C_final = (C_prerelease * V_h + C_postrelease * V_c) / V}

where V_h is the water volume in the hyporheic zone and V_c is the water
volume in the channel (surface water).

These estimates can be confirmed with the observed concentrations at the end
of the experimental release.

At all times during the release, the following equality should hold:

\code{C_final = (C_h_t * V_h + C_c_t * V_c)}

where "_t" designates a value at time (t) since the release. Importantly,
\code{C_c} at the end of the current time step affects the history of
interpolated \code{C_c} over the course of the time step and therefore
influences C_h at the end of the time step. Because C_c_t influences C_h_t,
there is only one value of C_c_t that will satisfy the equality.   Therefore,
at each time step of the model, the implicit solver finds the value of C_c
that minimizes the squared difference between each side of the equality. See
\code{\link{optimizationError}} for more details.
}
\examples{
m <- createFlume(
  # TIME parameters
  timestep = 0.5,
  duration = 60, #hours
  # Water age parameters
  shape = "powerLaw",
  alpha = 1.4,
  tau_0 = 1/3600,
  tau_n = 60,
  # Initial concentrations and volumes in channel and hyporheic zone.
  C_c = 10,
  C_h = 5,
  V = 1,
  V_h = 0.5,
  # Integration parameter.  See help for pIntegrate Function
  # Set >1 if integration quality is problematic; slows the model.
  nSubdiv = 1
)

#### RUN THE MODEL
simulateFlumeConcentration(m)

# plot output
plot(m$times, m$C_c, xlab = "Time (hours)", ylab = "Concentration")

# Assuming duration >= tau_n, compare simulated final conc to expected final conc
# to estimate of accuracy of model; smaller difference is better...
tail(m$C_c, 1) - m$C_final
}
